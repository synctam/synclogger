# SyncLogger レシーバー設計構想（アイデアメモ）

**注意:** このドキュメントは、正式な設計情報ではなく、ログ受信アプリケーションに関する設計アイデアや議論を記録した備忘録です。

---

## 基本方針：役割の分離

ログレシーバーは、ターゲットユーザーの異なる2つのアプリケーションに分割するアプローチを基本構想とする。

1.  **エンドユーザー向けレシーバー（ログ収集ツール）**: 誰でも簡単に、確実にログを収集し、開発者に提供できることに特化する。
2.  **開発者向けレシーバー（ログ分析ツール）**: 開発者が効率的かつ高度にログを分析できることに特化する。

この責務分離により、各ツールの目的が明確になり、それぞれに最適な技術選定と機能実装が可能となる。

---

## 1. エンドユーザー向けレシーバー（ログ収集ツール）

### 目的

エンドユーザー（プレイヤーなど）が、専門知識なしでデバッグ用のログファイルを生成し、開発者に提供できるようにする。

### 技術選定

**Godot Engine** を推奨する。

*   **メリット:**
    *   **簡単な配布**: 依存関係のない単一の実行ファイル（Windows, macOS, Linux）を書き出せる。ユーザーは環境構築が不要。
    *   **GUIの実装**: ユーザーに安心感と必要な情報を提供するための、シンプルで分かりやすいGUIを容易に作成できる。

### GUIの必要性

このツールには、以下の理由からGUIが**必須**である。

1.  **状態の可視化**: 「受信中」「停止中」といったアプリの状態を明示し、ユーザーに正常動作していることの安心感を与える。
2.  **重要情報の伝達**: ログの保存場所（フルパス）や、プライバシーに関する注意喚起などを画面上に明確に表示できる。
3.  **直感的な操作**: 「収集開始」「停止」「保存フォルダを開く」といった最小限の操作をボタンとして提供できる。

### 機能要件

*   UDPでログデータを受信する。
*   受信したデータを、タイムスタンプ付きのログファイルに追記する。
*   リアルタイムのログ表示は**行わない**（パフォーマンスとシンプルさを優先）。
*   GUI上に、現在の動作状態、受信ログ数、ログファイルの保存場所を表示する。

### 注意事項・考慮点

*   **アプリケーションサイズ**: Godotで書き出すため、実行ファイルのサイズが数MB〜数十MBになるが、配布の容易さと比較すれば許容範囲と判断する。
*   **ファイル管理**: ログの保存先は、ユーザーがアクセスしやすい場所（例: ドキュメントフォルダ）をデフォルトとする。
*   **プライバシー**: ログファイルに個人情報が含まれる可能性について、GUI上で明確に注意喚起を行う。

---

## 2. 開発者向けレシーバー（ログ分析ツール）

### 目的

開発者が、受信したログを**リアルタイムで観察**し、フィルタリング、検索、分析を効率的に行うための高機能ツールを提供する。特に、ゲーム内で特定の操作を行った際の挙動をその場で確認するなど、インタラクティブなバグ調査においてリアルタイム性は極めて重要となる。

### 技術選定

**Python, Rust** などの、ライブラリが豊富でパフォーマンスに優れた言語を推奨する。

*   **メリット:**
    *   **強力なエコシステム**: `rich` (TUI), `pandas` (データ分析), `matplotlib` (グラフ描画) など、目的に応じた強力なライブラリを活用できる。
    *   **高いパフォーマンス**: 大量のログをリアルタイムで処理・分析するのに適している。

### 配布モデル

**オープンソース**として公開する。

*   **メリット:**
    *   **コミュニティによる拡張**: 各開発者が自身のニーズに合わせてツールをカスタマイズ・拡張できる。
    *   **透明性**: ツールの動作が明確であり、開発者が安心して利用できる。

### 機能要件

*   リアルタイムでのログ表示。
*   ログレベルやカテゴリによる動的なフィルタリング。
*   キーワード検索機能。
*   ログの整形表示（色分けなど）。

### 注意事項・考慮点

*   **プロトコル仕様の文書化**: ログのJSONフォーマットを明確に定義し、バージョン管理することが極めて重要。これが開発者間の互換性を保つ鍵となる。
*   **リファレンス実装の提供**: すぐに使えるシンプルなPythonスクリプトをサンプルとして提供し、開発者がカスタマイズを始める際のハードルを下げる。
